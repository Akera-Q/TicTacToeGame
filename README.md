# TicTacToeGame

  First, in the html file, we make a <table> element which contains three rows (3 <tr>) each containing 3 <td> and the nine of these have the class "cells", each cell has its own id starting form the top left cell with "0" as an id and ending bottom right with "8" as an id.
  After this we add a <div> element which will contain a message when the game ends (for winning, losing or drawing) and it will also contain a button for starting a new game.

  In the css file we simply adjust the elements' positions and colors.

  In the Javascript file, first off we define a variables: origBoard contains the nine cells(I think). Next we define our constants: huPlayer is "O" and aiPlayer is "X", then we define each winning combo so the AI knows what to do, the next constant is "cells" which allows us to use the "cell" class without calling it each time.
  Now for functions, the first one "startGame" removes the "endgame" screen, and creates an array from the variable called origBoard which consists of 9 elements for each square, then it passes over each cell and removes any text in it, any background color it optained, and adds an event listener that triggers the turnClick function when a cell is clicked.
  The turnClick function first checks to see if the cicked square still has a value of a number (not yet assigned to X nor O), if it holds a value of X or O nothing happens, but if it's still a free square with a number for a value it gives it an X or an O depending on the whcih player clicked it, the human(huPlayer) or the AI(aiPlayer) with the help of turn function, it also checks to see if a tie happend using the checkTie function, if it's not a tie the AI makes its move and the game continues(this is likely the reason why it ends in a tie when the 9th cell is clicked, even if it could've been a win).
  *The turn function takes in two parameters, "squareId" which contains the index of the cell, and "player" which has two possibilities, huPlayer or aiPlayer, it then the text of the cell and changes it to either X or O depending on the player, after this it defines the "gameWon" variable, after calling the "checkWin" function and passing down the state of the board and the player, we store the results in it, and if a winning variation actually happens the "gameOver" functions gets called, it first takes information form "gameWon" then displays the ending screen with the winner.
  **The checkWin function uses the reduce method creates an array called "plays" which contains the player's moves, it then makes "gameWon" return null until a winning combination is met, the for loop first checks if any winning combination (win) is preset in the "plays" array using every(), "elem" represents each index of the current winning combination, then "plays.indexOf(elem) > -1" /*I don't get this part very well*/ checks to see if the player has occupied all the cells necessary to win, then if a win condition is met, "gameWon" is assigned with the index of that winning combination and the player, the loop then breaks so it won't check unnecessarily and "gameWon" returns with winning information or null.
   The gameOver function changes the cells of the winning combination into either blue if the human wins or red if the AI wins, then a for loop passes over each cell removing the event listener so no further inputs can be taken, then finally it displays an ending message depending on the state of the game(a win or a loss).
   The declareWinner function has two jobs, cahnging the style of the ".endgame" popup to "block" so it would be visible, and displaying the text of the message depending on the winner then it assigns it to "who" which is the function's parameter.
   the emptySquares function uses the filter method to make an array, the array consists of numbers(from the origBoard array) which represent the empty squares which are valid to be clicked on.
  The bestSpot function calls the "minimax" algorithm, it first passes the current state of the board "origBoard" and specifies that it's the AI's turn in "aiPlayer", it then takes the index that the minimax algorithm came out with and then it uses "turn(bestSpot(), aiPlayer)" ,after checking that the "huPlayer" didn't tie, it allows the AI to place its mark on the square that the minimax algorithm came out wiht, which is the best possible move.
  The checkTie function first assures that the "emptySquares" array's length is zero, meaning there are no more empty squares which results in a tie --COULD BE THE REASON WHY IT ENDS IN A TIE EVEN IF THE 9TH CLICK IS SUPPOSED TO BE A WIN-- then it loops over each cell changing its background color to green and removing event listener which prevents further moves, it then calls "declareWinner" with a message that indicates that the game is a tie, and then it simply returns true if it's a tie or false if there are empty squares left.
  The minimax function as its name suggests uses the minimax algorithm to calculate the best move for the AI.
